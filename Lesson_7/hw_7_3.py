# Homework:  Lesson 7. Task 3

"""
 Реализовать программу работы с органическими клетками, состоящими из ячеек. Необходимо
создать  класс  Клетка.  В  его  конструкторе  инициализировать  параметр,  соответствующий
количеству  ячеек  клетки  (целое  число).  В  классе  должны  быть  реализованы  методы
перегрузки  арифметических  операторов:  сложение  (​__add__()​),  вычитание  (​__sub__()​),
умножение (​__mul__()​), деление (​__truediv__()​). Данные методы должны применяться ​только
к клеткам и выполнять увеличение, уменьшение, умножение и целочисленное (с округлением
до целого) деление клеток, соответственно.

Сложение​. Объединение двух клеток. При этом число ячеек общей клетки должно равняться
сумме ячеек исходных двух клеток.

Вычитание​. Участвуют две клетки. Операцию необходимо выполнять только если разность
количества ячеек двух клеток больше нуля, иначе выводить соответствующее сообщение.

Умножение​. Создается общая клетка из двух. Число ячеек общей клетки определяется как
произведение количества ячеек этих двух клеток.

Деление​.  Создается  общая  клетка  из  двух.  Число  ячеек  общей  клетки  определяется  как
целочисленное деление количества ячеек этих двух клеток.

В  классе  необходимо  реализовать  метод  ​make_order()​,  принимающий  экземпляр  класса  и
количество ячеек в ряду. Данный метод позволяет организовать ячейки по рядам.

Метод  должен  возвращать  строку  вида  ​*****\n*****\n*****​...,  где  количество  ячеек  между  ​\n
равно переданному аргументу. Если ячеек на формирование ряда не хватает, то в последний
ряд записываются все оставшиеся.

Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод
make_order() ​вернет строку: ​*****\n*****\n**​.
Или,  количество  ячеек  клетки  равняется  15,  количество  ячеек  в  ряду  —  5.  Тогда  метод
make_order() ​вернет строку: ​*****\n*****\n*****​.

"""


class Cage:
    def __init__(self, cell_count):
        self.cell_count = cell_count

    def __add__(self, other):
        if type(self) != type(other):            raise TypeError
        return Cage(self.cell_count + other.cell_count)

    def __sub__(self, other):
        if type(self) != type(other):            raise TypeError
        if self.cell_count < other.cell_count:
            print("отрицательная разность")
            raise ValueError
        return Cage(self.cell_count - other.cell_count)

    def __mul__(self, other):
        if type(self) != type(other):            raise TypeError
        return Cage(self.cell_count * other.cell_count)

    def __truediv__(self, other):
        if type(self) != type(other):            raise TypeError
        return Cage(int(self.cell_count // other.cell_count))

    def make_order(self, cnt):
        return ("*" * cnt + "\n") * (self.cell_count // cnt) + "*" * (self.cell_count % cnt)


ca_12 = Cage(12)
ca_15 = Cage(15)
print(ca_12.make_order(5))
print("")
print(ca_15.make_order(5))
print("")

print((ca_15 + ca_12).cell_count)
print((ca_15 - ca_12).cell_count)
print((ca_15 * ca_12).cell_count)
print((ca_15 / ca_12).cell_count)
print((ca_12 / ca_15).cell_count)
try:
    print((ca_12 - ca_15).cell_count)
except ValueError:
    pass
